{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/main.ts","src/metrochart.ts","src/metrocharterror.ts"],"names":["f","exports","module","define","amd","g","window","global","self","this","metrochart","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","metrochart_1","MetroChart","metrocharterror_1","MetroChartError","elem","url","options","_url","elemid","document","getElementById","updateWidthHeight","applyDefaultOptions","defaultOptions","loaddata","that","addEventListener","onResize","prototype","draw","calcUniqueLines","verifyData","drawForceDirectedGraph","colors","_i","_a","color","push","hexcode","_b","_c","charge","gravity","linkDistance","linkStrength","enableTimeAxis","stationShapeRadius","labelSpaceVert","labelRotation","padding","calcLinkShape","link","str","source","xf","x","yf","y","calcStubOffset","xt","target","yt","calcLabelTopOrBottom","station","yTop","yBottom","h","distToTop","distToBottom","calcLabelTranslate","observeBoundingBox","topOrBottom","calcStationShape","node","calcStationShapeArc","fromy","topOrBottomStr","iSection","nSections","outputStr","angle","dx","dy","Math","PI","cos","sin","hw","hh","nLines","calcStationTranslate","time","timeValueLeft","timeValueRight","left","w","right","sourceOrTargetStr","stubIndex","stubOffset","linesAtSource","nodes","index","lines","indexOf","line","linesAtTarget","ulinks","links","sort","uindex","calcVerticalLine","halfStationHeight","buffer","onMouseOutNodeGroup","eventsource","children","d3","select","selectAll","classed","onMouseOverNodeGroup","each","parentNode","appendChild","onMouseOutMetroLine","datum","classname","onMouseOverMetroLine","vis","append","attr","force","layout","size","data","enter","d","style","getColor","on","console","log","linelabel","nodeGroup","label","text","name","vline","stationlabel","drag","start","div","firstChild","removeChild","nColors","xmlHttp","XMLHttpRequest","onreadystatechange","status","readyState","JSON","parse","responseText","datasource","open","send","getBoundingClientRect","width","height","Object","defineProperty","_colors","_enableTimeAxis","_charge","_linkDistance","_gravity","_linkStrength","_super","__extends","message"],"mappings":"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","file":"dist/metrochart.min.js","sourceRoot":"","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/**\r\n * MetroChart module\r\n */\r\n\r\n\r\nexport {MetroChart} from './metrochart';\r\nexport {MetroChartData} from './metrochartdata';\r\nexport {MetroChartError} from './metrocharterror';\r\nexport {MetroLine} from './metroline';\r\nexport {Options} from './options';\r\nexport {Station} from './station';\r\n\r\n","\r\nimport {MetroChartData} from './metrochartdata';\r\nimport {MetroChartError} from './metrocharterror';\r\nimport {MetroLine} from './metroline';\r\nimport {Options} from './options';\r\nimport {Station} from './station';\r\n\r\n\r\nimport 'd3';\r\n\r\n/**\n * <p>\n * A MetroChart is a force-directed graph. Being a graph, it is made up of nodes\n * and links. The nodes represent stations (see interface {@link Station}) while\n * the links represent metrolines (see interface {@link MetroLine}).\n * </p>\n *\n * <p>\n * The data may include an attribute <code>time</code> on each node. The property\n * may be used to order nodes along the horizontal axis (by setting\n * <code>this.enableTimeAxis</code> to <code>true</code>). This is convenient\n * for visualizing certain types of data, such as narratives in stories or plays\n * (which character occurs together with which other characters in any given\n * scene, with nodes representing scenes and links representing characters).\n * </p>\n */\nexport class MetroChart {\r\n\n\n\n    /**\n     * The JSON data may include an optional <code>source</code> property (see\n     * interface {@link MetroChartData}). Property <code>this.datasource</code>\n     * stores the data source, or if the data source is omitted from the JSON,\n     * <code>this.datasource</code> is set to <code>'unknown'</code>.\n     */\n    public datasource: string;\n    /**\n     * Identifier of the DOM element such as <code>metrochart</code>, in\r\n     * which to draw the MetroChart.\n     */\n    private elem: string;\r\n    /**\n     *\r\n     */\n    private elemid: HTMLElement;\r\n    /**\n     * The height of the DOM element containing the MetroChart.\n     */\n    private h: number;\n    /**\n     * When the graph is visualized, station names can be displayed in a\n     * reserved area at the top of the visualization as well as at the bottom.\n     * This property sets the height of these reserved areas.\n     */\n    private labelSpaceVert: number;\n    /**\n     * Defines the rotation of the station labels.\n     */\n    private labelRotation: number;\n    /**\n     * The graph is padded to avoid having elements very close to the left-side\n     * and right-side edges of the visualization, or even falling off of it.\n     * This property defines how much padding there is (in pixels). Note that\n     * the bounding box takes into account the padding value.\n     */\n    private padding: {left:number, right:number};\n    /**\n     * When the data represents different entities than metrolines and stations\n     * this property may be used to define an alternative name to identify\n     * metrolines. Let's say your data represents the storyline of a comic book,\n     * then individual frames could be represented by a station, while the\n     * characters that occur in a frame could be represented by a line. In this\n     * case, <code>this.stationlabel</code> could be set to <code>'frame'</code>\n     * and <code>this.linelabel</code> could be set to <code>'character'</code>.\n     */\n    public linelabel: string;\n    /**\n     * The list of links/metrolines, pointing to the indices of two nodes/\n     * stations.\n     */\n    private links: MetroLine[];\n    /**\n     * The list of stations.\n     */\n    private nodes: Station[];\n    /**\n     * When the data represents different entities than metrolines and stations\n     * this property may be used to define an alternative name to identify\n     * stations. Let's say your data represents the storyline of a comic book,\n     * then individual frames could be represented by a station, while the\n     * characters that occur in a frame could be represented by a line. In this\n     * case, <code>this.stationlabel</code> could be set to <code>'frame'</code>\n     * and <code>this.linelabel</code> could be set to <code>'character'</code>.\n     */\n    public stationlabel: string;\n    /**\n     * Radius in pixels used in drawing the station symbols.\n     */\n    public stationShapeRadius: number;\n    /**\n     * The time value corresponding to the left-most pixel.\n     */\n    public timeValueLeft: number;\n    /**\n     * The time value corresponding to the right-most pixel.\n     */\n    public timeValueRight: number;\n    /**\n     * List of strings containing the unique metroline names.\n     */\n    private ulinks: string[];\n    /**\n     * The URL of where the data is located. Data should be compliant with the\n     * {@link MetroChartData} interface.\n     */\n    private _url: string;\n    /**\n     * The width of the DOM element containing the MetroChart.\n     */\n    private w: number;\n    /**\n     * See {@link Options.colors}.\n     */\n    private _colors: string[];\n    /**\n     * Defines the charge parameter of the force-directed graph.\n     */\n    private _charge: number;\n    /**\n     * See {@link Options.enableTimeAxis}.\n     */\n    private _enableTimeAxis: boolean;\n    /**\n     * Defines the gravity parameter of the force-directed graph.\n     */\n    private _gravity: number;\n    /**\n     * Defines the link distance parameter of the force-directed graph.\n     */\n    private _linkDistance: number;\n    /**\n     * Defines the link strength parameter of the force-directed graph.\n     */\n    private _linkStrength: number;\n    /**\n     * See {@link Options}.\n     */\n    private static defaultOptions: Options = {\n        /**\n         * See {@link Options.charge}.\n         */\n        charge: 0,\n        /**\n         * See {@link Options.colors}. Here are the default colors:\n         * <table>\n         *    <tr><td>1.</td><td bgcolor=\"#FF0000\"></td><td>red</td></tr>\n         *    <tr><td>2.</td><td bgcolor=\"#008000\"></td><td>olive</td></tr>\n         *    <tr><td>3.</td><td bgcolor=\"#0080FF\"></td><td>blue</td></tr>\n         *    <tr><td>4.</td><td bgcolor=\"#FF8000\"></td><td>orange</td></tr>\n         *    <tr><td>5.</td><td bgcolor=\"#FF0080\"></td><td>magenta</td></tr>\n         *    <tr><td>6.</td><td bgcolor=\"#FFee00\"></td><td>yellow</td></tr>\n         *    <tr><td>7.</td><td bgcolor=\"#80DD00\"></td><td>lime</td></tr>\n         *    <tr><td>8.</td><td bgcolor=\"#b200ff\"></td><td>purple</td></tr>\n         *    <tr><td>9.</td><td bgcolor=\"#00DD80\"></td><td>seagreen</td></tr>\n         *    <tr><td>10.</td><td bgcolor=\"#888888\"></td><td>dark gray</td></tr>\n         *    <tr><td>11.</td><td bgcolor=\"#000000\"></td><td>black</td></tr>\n         * </table>\n         */\n        colors: [\n            {name: 'red',       hexcode: '#FF0000'},\n            {name: 'olive',     hexcode: '#008000'},\n            {name: 'blue',      hexcode: '#0080FF'},\n            {name: 'orange',    hexcode: '#FF8000'},\n            {name: 'magenta',   hexcode: '#FF0080'},\n            {name: 'yellow',    hexcode: '#FFee00'},\n            {name: 'lime',      hexcode: '#80DD00'},\n            {name: 'purple',    hexcode: '#b200ff'},\n            {name: 'seagreen',  hexcode: '#00DD80'},\n            {name: 'dark gray', hexcode: '#888888'},\n            {name: 'black',     hexcode: '#000000'}\n        ],\n        /**\n         * See {@link Options.enableTimeAxis}.\n         */\n        enableTimeAxis: true,\n        /**\n         * See {@link Options.gravity}.\n         */\n        gravity: 0.0005,\n        /**\n         * See {@link Options.labelSpaceVert}.\n         */\n        labelSpaceVert: 130,\n        /**\n         * See {@link Options.labelRotation}.\n         */\n        labelRotation: -45,\n        /**\n         * See {@link Options.padding}.\n         */\n        padding: {left:50, right:50},\n        /**\n         * See {@link Options.linkDistance}.\n         */\n        linkDistance: 1,\n        /**\n         * See {@link Options.linkStrength}.\n         */\n        linkStrength: 0.0,\n        /**\n         * See {@link Options.stationShapeRadius}.\n         */\n        stationShapeRadius: 7.0\n    };\n\n    /**\n     * Create a new MetroChart instance.\n     * @param {string} elem The name of the DOM element in which you want to\n     * draw the MetroChart.\n     *\n     * @param {string} url The URL of the data file, which should be a JSON file\n     * formatted according to the <code>MetroChartData</code> interface.\n     *\n     * @param {Options} [options] Optional parameter containing the options.\n     *\n     */\n    constructor(elem: string, url:string, options?:Options) {\n\n        // store the string containing the DOM element ID\n        this.elem = elem;\r\n\n        // store the url to the data that was provided by the user\n        this._url = url;\n\n        //\r\n        this.elemid = document.getElementById(this.elem);\r\n\n        // store the width and height of the DOM element we want to draw in\r\n        this.updateWidthHeight();\r\n\r\n        if (typeof options === 'undefined') {\n            this.applyDefaultOptions(MetroChart.defaultOptions);\n        } else {\n            this.applyDefaultOptions(options);\n        }\n\n        // load the data (internally defers to this.drawForceDirectedGraph() )\n        this.loaddata();\r\n\r\n        // beware: JavaScript magic happens here\r\n        let that:MetroChart = this;\r\n        window.addEventListener('resize', function() {\r\n            that.onResize();\r\n        });\r\n\r\n\n    } // end method constructor()\n\n\r\n\r\n    public draw() {\r\n\r\n        // get the current width and height\r\n        this.updateWidthHeight();\r\n        // determine the list of unique line names:\r\n        this.calcUniqueLines();\r\n        // verify the data and add some properties:\r\n        this.verifyData();\r\n        // draw the force directed graph:\r\n        this.drawForceDirectedGraph();\r\n\r\n    }\r\n\r\n\n\n    /**\n     * @param {Options} options User supplied options that override the default\n     * options from {@link MetroChart.defaultOptions}.\n     *\n     */\n    public applyDefaultOptions(options?:Options): MetroChart {\n\n        // set the colors:\n        let colors: string[];\n        colors = [];\n        if (typeof options.colors === 'undefined') {\n            // use default colors\n            for (let color of MetroChart.defaultOptions.colors) {\n                colors.push(color.hexcode);\n            }\n        } else {\n            // use user-supplied colors\n            for (let color of options.colors) {\n                colors.push(color.hexcode);\n            }\n        }\n        this.colors = colors;\n\n\n        // set the force directed graph parameter 'charge'\n        if (typeof options.charge === 'undefined') {\n            // use default\n            this.charge = MetroChart.defaultOptions.charge;\n        } else {\n            // use user supplied value\n            this.charge = options.charge;\n        }\n\n\n        // set the force directed graph parameter 'gravity'\n        if (typeof options.gravity === 'undefined') {\n            // use default\n            this.gravity = MetroChart.defaultOptions.gravity;\n        } else {\n            // use user supplied value\n            this.gravity = options.gravity;\n        }\n\n\n        // set the force directed graph parameter 'linkDistance'\n        if (typeof options.linkDistance === 'undefined') {\n            // use default\n            this.linkDistance = MetroChart.defaultOptions.linkDistance;\n        } else {\n            // use user supplied value\n            this.linkDistance = options.linkDistance;\n        }\n\n\n        // set the force directed graph parameter 'linkStrength'\n        if (typeof options.linkStrength === 'undefined') {\n            // use default\n            this.linkStrength = MetroChart.defaultOptions.linkStrength;\n        } else {\n            // use user supplied value\n            this.linkStrength = options.linkStrength;\n        }\n\n\n        // define whether to enable the time axis\n        if (typeof options.enableTimeAxis === 'undefined') {\n            // use default\n            this.enableTimeAxis = MetroChart.defaultOptions.enableTimeAxis;\n        } else {\n            // use user supplied value\n            this.enableTimeAxis = options.enableTimeAxis;\n        }\n\n\n        // set the radius of the station symbols\n        if (typeof options.stationShapeRadius === 'undefined') {\n            // use default\n            this.stationShapeRadius = MetroChart.defaultOptions.stationShapeRadius;\n        } else {\n            // use user supplied value\n            this.stationShapeRadius = options.stationShapeRadius;\n        }\n\n        // set the vertical space reserved for plotting the station labels\n        if (typeof options.labelSpaceVert === 'undefined') {\n            // use default\n            this.labelSpaceVert = MetroChart.defaultOptions.labelSpaceVert;\n        } else {\n            // use user supplied value\n            this.labelSpaceVert = options.labelSpaceVert;\n        }\n\n        // set the station label rotation\n        if (typeof options.labelRotation === 'undefined') {\n            // use default\n            this.labelRotation = MetroChart.defaultOptions.labelRotation;\n        } else {\n            // use user supplied value\n            this.labelRotation = options.labelRotation;\n        }\n\n        // set the MetroChart's internal spacing (padding)\n        if (typeof options.padding === 'undefined') {\n            // use default\n            this.padding = MetroChart.defaultOptions.padding;\n        } else {\n            // use user supplied value\n            this.padding = options.padding;\n        }\n\n\n\n        return this;\n    } // end method applyDefaultOptions()\n\n\n\n\n    /**\n     * Method to calculate the position of the lines connecting the stations.\n     * The method takes into account how many lines there are at each station,\n     * so the vertical offset can be calculated by <code>this.calcStubOffset()</code>.\n     *\n     * @param {MetroLine} link The link between two Stations.\n     *\n     * @return {string} The SVG path string describing the position of the line.\n     *\n     */\n    private calcLinkShape(link: MetroLine): string {\n        // determine the coordinates of the given link\n\n        let str:string = '';\n\n        // draw straight lines between nodes\n\n        // The first time this method gets called, source and target are\n        // simply integer numbers, not objects with .x and .y properties.\n        // Therefore you need these two if-statements to make sure you don't\n        // generate any errors:\n        if (typeof link.source === 'object') {\n\n            // x-from\n            let xf: number = link.source.x;\n            // y-from\n            let yf: number = link.source.y + this.calcStubOffset(link, 'source');\n\n            str += 'M' + xf + ',' + yf + ' ';\n\n        } else {\n            // starting point of a temporary line (only displayed in the very first frame)\n            str += 'M0,0 ';\n        }\n        if (typeof(link.target) === 'object') {\n\n            // x-to\n            let xt: number = link.target.x;\n            // y-to\n            let yt: number = link.target.y + this.calcStubOffset(link, 'target');\n\n            str += 'L' + xt + ',' + yt;\n\n        } else {\n            // ending point of a temporary line (only displayed in the very first frame)\n            str += 'L10,10';\n        }\n\n        return str;\n\n    } // end method calcLinkShape()\n\n\n\n    /**\n     * When drawing the vertical line from station to label, you need to know\n     * whether to draw to the bottom reserved area or the top reserved area.\n     * This method determines whether the bottom reserved area or the top\n     * reserved area is closest to the position of the station. This is then\n     * used in drawing the station-to-label vertical line, as well as in\n     * calculating the position of the station labels.\n     *\n     * @param  {Station} station The station for which we want to determine\n     * which is closer --the top reserved area or the bottom one.\n     *\n     * @return {string} Either <code>'top'</code> or <code>'bottom'</code>.\n     *\n     */\n    calcLabelTopOrBottom(station: Station):string {\n\n        let yTop:number = 0 + this.labelSpaceVert;\n        let yBottom:number = this.h - this.labelSpaceVert;\n\n        let distToTop:number = station.y - yTop;\n        let distToBottom:number = yBottom - station.y;\n\n        if (distToTop < distToBottom) {\n            return 'top';\n        } else {\n            return 'bottom';\n        }\n    }\n\n\n\n    /**\n     * The stations are labeled with their names. These labels are drawn in\n     * one of two reserved plotting areas, one near the bottom of the graph and\n     * one near the top. This method determines which is closer, and the returns\n     * the translation needed for the label to be correctly placed, i.e.\n     * horizontally aligned with the position of the station, and vertically\n     * aligned so it falls in either the bottom or the top reserved area. The\n     * translation also includes a rotation, which can be set through\n     * MetroChart's options (see {@link Options.labelRotation}).\n     *\n     * @param  {Station} station The station for which you want to draw a\n     * label.\n     *\n     * @return {[type]} The translation that must be applied to position the\n     * label such that it is horizontally aligned with the position of the\n     * station proper, and vertically aligned with the bottom or top reserved\n     * area. The translation also includes a rotation, which can be set through\n     * MetroChart's options (see {@link Options.labelRotation}).\n     *\n     */\n    calcLabelTranslate(station: Station) {\n\n        let yTop:number = 0 + this.labelSpaceVert;\n        let yBottom:number = this.h - this.labelSpaceVert;\n\n\n        // apply the bounding box\n        station = this.observeBoundingBox(station);\n\n        let topOrBottom:string = this.calcLabelTopOrBottom(station);\n\n\n        if (topOrBottom === 'top') {\n            return 'translate(' + station.x + ',' + (yTop - 10 - 15) + ') rotate(' + this.labelRotation + ')';\n        } else if (topOrBottom === 'bottom') {\n            return 'translate(' + station.x + ',' + (yBottom + 10 + 15) + ') rotate(' + this.labelRotation + ')';\n        } else {\n            throw new MetroChartError('This should not happen.');\n        }\n    }\n\n\n\n\n\n    /**\n     * Method that calculates the shape of the station symbol.\n     *\n     * @param {Station} node The station for which to draw a symbol.\n     *\n     * @return {string} String containing the SVG path 'd' data for the\n     * station symbol.\n     */\n    private calcStationShape(node: Station): string {\n\n\n\n\n        /**\n         * Local function that calculates the shape of the station symbol's top\n         * or bottom part.\n         *\n         * @param {number} fromy The y-value of where the arc should start.\n         *\n         * @param {number} r The radius of the arc.\n         *\n         * @param {string} topOrBottomString Whether the method is used to draw\n         * the top part or the bottom part.\n         *\n         * @return {string} String containing the SVG path 'd' data (for the\n         * part that describes the top or bottom arc).\n         *\n         */\n        let calcStationShapeArc = function(fromy:number, r:number, topOrBottomStr:string): string {\n\n            let iSection: number;\n            let nSections: number;\n            let outputStr:string;\r\n            let angle: number;\n            let dx: number;\n            let dy: number;\n\n            nSections = 8;\n            outputStr = '';\n\n            if (topOrBottomStr === 'top') {\n                for (iSection = 0; iSection <= nSections; iSection += 1) {\n                    angle = (nSections - iSection) / nSections * Math.PI;\n                    dx = Math.cos(angle) * r;\n                    dy = Math.sin(angle) * -r;\n                    outputStr += 'L ' + (dx) + ' ' + (fromy + dy) + ' ';\n                }\n                return outputStr;\n            } else if (topOrBottomStr === 'bottom') {\n                for (iSection = 0; iSection < nSections; iSection += 1) {\n                    angle = (iSection) / nSections * Math.PI;\n                    dx = Math.cos(angle) * r;\n                    dy = Math.sin(angle) * r;\n                    outputStr += 'L ' + (dx) + ' ' + (fromy + dy) + ' ';\n                    }\n                return outputStr;\n            } else {\n                throw new MetroChartError(' in .calcStationShapeArc(): \\'Fourth argument should be either \\'top\\' or \\'bottom\\'.\\'');\n            }\n        }; // end local method calcStationShapeArc\n\n\n\n\n\n        // half the width of the entire station symbol\n        let hw: number = this.stationShapeRadius;\n        // half the height of the entire station symbol\n        let hh: number = node.nLines * this.stationShapeRadius;\n\n        let str: string = 'M ' + (-hw) + ' 0 ' +\n                          'L ' + (-hw) + ' ' + ((node.nLines - 1) * -this.stationShapeRadius) + ' ' +\n                          calcStationShapeArc((node.nLines - 1) * -this.stationShapeRadius, this.stationShapeRadius, 'top') +\n                          'L ' + (+hw) + ' ' + ((node.nLines - 1) * this.stationShapeRadius) + ' ' +\n                          calcStationShapeArc((node.nLines - 1) * this.stationShapeRadius, this.stationShapeRadius, 'bottom') +\n                          'L ' + (-hw) + ' ' + ((node.nLines - 1) * this.stationShapeRadius) + ' ' +\n                          'Z';\n         return str;\n    } // end method calcStationShape()\n\n\n\n\n    /**\n     * Method that calculates the translation of the station symbol, while\n     * observing the bounding box set by the dimensions of the SVG area and the\n     * dimension of the station symbols.\n     *\n     * @param {Station} node The station that needs to be translated.\n     *\n     * @return {string} String containing the translate offsets.\n     *\n     */\n    private calcStationTranslate(node:Station): string {\n\n\n        // if nodes have time labels and time axis is enabled, set x-position\n        if (typeof node.time === 'number' && this.enableTimeAxis === true) {\n            // calculate the fraction\n            let f: number = (node.time - this.timeValueLeft) / (this.timeValueRight - this.timeValueLeft);\n\n            node.x = this.padding.left + f * (this.w - this.padding.right - this.padding.left);\n        }\n\n        // apply the bounding box\n        node = this.observeBoundingBox(node);\n\n        return 'translate(' + node.x + ',' + node.y + ')';\n\n    }\n\n\n\n\n    /**\n     * Method to calculate the vertical offset that indicates that there is more\n     * than one line at a station.\n     *\n     * @param {MetroLine} link The link object connecting two stations.\n     *\n     * @param {string} sourceOrTargetString The stub's offset can be different\n     * at the source than at the target nodes, this parameter indicates which we\n     * are currently calculating.\n     *\n     * @return {number} The vertical offset in pixels.\n     *\n     */\n    private calcStubOffset(link: MetroLine, sourceOrTargetStr:string): number {\n        // a node can have multiple lines coming from it. The order is\n        // determined by the current method\n        let stubIndex: number;\n        let stubOffset: number;\n        let nLines: number;\n\n        if (sourceOrTargetStr === 'source') {\n            let linesAtSource = this.nodes[link.source.index].lines;\n            nLines = linesAtSource.length;\n            stubIndex = linesAtSource.indexOf(link.line);\n        } else if (sourceOrTargetStr === 'target') {\n            let linesAtTarget = this.nodes[link.target.index].lines;\n            nLines = linesAtTarget.length;\n            stubIndex = linesAtTarget.indexOf(link.line);\n        } else {\n            throw new MetroChartError(' in .calcStubOffset(): \\'Input argument sh' +\n                                      'ould be \\'source\\' or \\'target\\' .\\'');\n        }\n        stubOffset = -1 * (nLines * this.stationShapeRadius - this.stationShapeRadius) + (stubIndex * 2 * this.stationShapeRadius);\n        return stubOffset;\n\n    }\n\n\n\n\n    /**\n     * Method to calculate the set of unique line names, <code>this.ulinks</code>.\n     */\n    private calcUniqueLines(): void {\n        // initialize the array that is going to hold the unique names of lines\n        this.ulinks = [];\n        // iterate over the links, whenever you see a previously unseen line name,\n        // add it to the list of strings in this.ulinks\n        for (let link of this.links) {\n            if (this.ulinks.indexOf(link.line) === -1 ) {\n                this.ulinks.push(link.line);\n            }\n        }\n        // sort the list of unique line names\n        this.ulinks.sort();\n        // assign the index of each link's line name to property .uindex\n        for (let link of this.links) {\n            link.uindex = this.ulinks.indexOf(link.line);\n        }\n    }\n\n\n    /**\n     * The svg drawing area has two reserved areas, one at the top and one at\n     * the bottom. These area are reserved for labels containing the station\n     * names. This method draws a line between the a node of the graph and the\n     * station label proper.\n     *\n     * @param  {Station} station The node for which line must be drawn to its\n     * label.\n     *\n     * @return {string} The SVG path \"d\" string data.\n     *\n     */\n    calcVerticalLine(station: Station): string {\n\n        let h:number = this.labelSpaceVert;\n        let yTop:number = 0 + h;\n        let yBottom:number = this.h - h;\n\n        let distToTop:number = station.y - yTop;\n        let distToBottom:number = yBottom - station.y;\n\n        // apply the bounding box\n        station = this.observeBoundingBox(station);\n\n        let halfStationHeight: number = station.nLines * this.stationShapeRadius;\n\n        let buffer: number = 30;\n\n        if (distToTop < distToBottom) {\n            return 'M ' + station.x + ' ' + (station.y - halfStationHeight - 5) + ' ' +\n                   'L ' + station.x + ',' + (yTop - buffer + 15);\n        } else {\n            return 'M ' + station.x + ' ' + (station.y + halfStationHeight + 5) + ' ' +\n                   'L ' + station.x + ',' + (yBottom + buffer - 15);\n        }\n    }\n\n\n\n\n\n    /**\n     * Draw/update force-directed metrochart graph using the current settings.\n     */\n    public drawForceDirectedGraph(): MetroChart {\n\n        // define onMouseOutNodeGroup as a local function to the drawForceDirectedGraph() method\n        let onMouseOutNodeGroup = function(eventsource:any) {\r\n            //  Note the d3 selector magic that is applied here. I get the\n            //  source of the event, which is an svg group, and on that\n            //  selection I subselect everything of class 'nodegroup-child' (which\n            //  I set myself when I created the child objects). On that\n            //  selection, I remove the class 'highlight' which was set by\n            //  onMouseOver() using d3's classed method:\n            let children = d3.select(eventsource).selectAll('.nodegroup-child');\n            // remove class 'highlight' from all children:\n            children.classed('highlight', false);\n        };\n\n        // define onMouseOverNodeGroup as a local function to the drawForceDirectedGraph() method\n        let onMouseOverNodeGroup = function(eventsource:any) {\r\n            //  Note the d3 selector magic that is applied here. I get the\n            //  source of the event, which is an svg group, and on that\n            //  selection I subselect everything of class 'nodegroup-child' (which\n            //  I set myself when I created the child objects). On that\n            //  selection, I add a class using d3's classed method:\n            let children = d3.select(eventsource).selectAll('.nodegroup-child');\n            // add the class 'highlight' to all children, so that the element\n            // can be styled using CSS\n            children.classed('highlight', true);\n\n            // bring the svg group that generated the event to the foreground by\n            // re-ordering the '.nodegroup-parent' svg groups\n            d3.selectAll('.nodegroup-parent').each(function(){\n                if (this === eventsource) {\n                    this.parentNode.appendChild(this);\n                };\n            });\n\n        };\n\n        // define onMouseOutMetroLine as a local function to the drawForceDirectedGraph() method\n        let onMouseOutMetroLine = function(eventsource:any) {\r\n            // Here, 'eventsource' refers to the line segment (path)\n            // that generated the event, not the instance of MetroChart!\n            let uindex: number = d3.select(eventsource).datum().uindex;\n            let classname = '.link.line' + uindex;\n            d3.selectAll(classname).classed('highlight', false);\n        };\n\n        // define onMouseOverMetroLine as a local function to the drawForceDirectedGraph() method\n        let onMouseOverMetroLine = function(eventsource:any) {\r\n            // Here, 'eventsource' refers to the line segment (path)\n            // that generated the event, not the instance of MetroChart!\n            let uindex: number = d3.select(eventsource).datum().uindex;\n            let classname = '.link.line' + uindex;\n            d3.selectAll(classname).classed('highlight', true);\n        };\n\r\n\n        // capture the 'this' object:\n        let that = this;\n\n        // select the DOM element to draw in, and set its identifier, as well\r\n        // as its width and height\n        let vis = d3.select(this.elemid).append('svg')\r\n            .attr('width', this.w)\r\n            .attr('height', this.h);\n\n        // initialize the force layout, set its width and height, then update it with\n        // the nodes and links arrays (which initially are empty),\n        let force = d3.layout.force()\n            .size([this.w, this.h])\n            .nodes(this.nodes)\n            .links(this.links);\n\n        // set the directed-graph force parameters:\n        force.charge(this.charge);\n        force.gravity(this.gravity);\n        force.linkDistance(this.linkDistance);\n        force.linkStrength(this.linkStrength);\n\n        // In this next part, the order in which link, vline, node etc are\n        // initialized is significant for which object is drawn on top of which\n        // object\n\n        // initialize the links between stations\n        let link = vis.selectAll('.link')\n            .data(this.links)\n            .enter().append('path')\n                .attr('class', function(d:MetroLine) {return 'link' + ' ' + 'line' + d.uindex; } )\n                .attr('d', function(d:MetroLine) {return that.calcLinkShape(d); })\n                .style('stroke', function(d:MetroLine) {return that.getColor(d.uindex); })\n                .on('click', function(d:MetroLine) {console.log(that.linelabel + ' ' + d.line); })\n                .on('mouseover', function() {\n                    // somehow the 'this' object does not refer to the instance\n                    // of MetroChart here, but to the event that generated the\n                    // mouseover event, in this case the line segment.\n                    let eventsource = this;\n                    onMouseOverMetroLine(eventsource); } )\n                .on('mouseout', function() {\n                    // somehow the 'this' object does not refer to the instance\n                    // of MetroChart here, but to the event that generated the\n                    // mouseout event, in this case the line segment.\n                    let eventsource = this;\n                    onMouseOutMetroLine(eventsource);\n                });\n\n\n        // make a group of class nodegroup that will contain the station symbol,\n        // the vertical line, and the station label:\n        let nodeGroup = vis.selectAll('.node')\n            .data(this.nodes)\n            .enter().append('g')\n            .attr('class', 'nodegroup-parent')\n            .on('mouseover', function() {\n                // somehow the 'this' object does not refer to the instance\n                // of MetroChart here, but to the event that generated the\n                // mouseover event, in this case the svg group element.\n                let eventsource = this;\n                onMouseOverNodeGroup(eventsource); } )\n            .on('mouseout', function() {\n                // somehow the 'this' object does not refer to the instance\n                // of MetroChart here, but to the event that generated the\n                // mouseout event, in this case the svg group element.\n                let eventsource = this;\n                onMouseOutNodeGroup(eventsource);\n            });\n\n        // label the nodes by adding their name as text\n        let label = nodeGroup.append('text')\n            .attr('class', 'label nodegroup-child')\n            .attr('transform', 'translate(0,0) rotate(45)')\n            .text(function(d:Station) {return d.name; });\n\n        // draw a vertical line from each node to its corresponding label:\n        let vline = nodeGroup.append('path')\n            .attr('class', 'vline nodegroup-child')\n            .attr('d', function(d:Station) {return that.calcVerticalLine(d); });\n\n        // draw the station symbol:\n        let node = nodeGroup.append('path')\n                .attr('class', 'node nodegroup-child')\n                .attr('d', function(d:Station) {return that.calcStationShape(d); })\n                .on('click', function(d:Station) {console.log(that.stationlabel + ' ' + d.index + ': ' + d.name); })\n                .call(force.drag);\n\n\n        force.on('tick', function(e) {\n\n            // This is actually a loop in which the force-directing algorithm\n            // adjusts the values of node.x and node.y for all node of\n            // this.nodes. Since you want to have a consistent visualization,\n            // you need to make sure that the other components (i.e. the\n            // metrolines, the station-to-label lines, and the labels) move with\n            // the moving nodes.\n            node.attr('transform', function(d:Station) {return that.calcStationTranslate(d); });\n\n            // update the position of the station labels\n            label.attr('transform', function(d:Station) {return that.calcLabelTranslate(d); })\n                .style('text-anchor', function(d:Station) {\n                    let topOrBottom:string = that.calcLabelTopOrBottom(d);\n                    if (topOrBottom === 'top') {\n                        return 'start';\n                    } else if (topOrBottom === 'bottom') {\n                        return 'end';\n                    } else {\n                        throw new MetroChartError('This should not happen.');\n                    }\n                });\n\n\n            // update the position of the station-to-label vertical lines\n            vline.attr('d', function(d:Station) {return that.calcVerticalLine(d); });\n\n            // for each link of this.links, recalculate the path connecting the stations (since\n            // these were just changed)\n            link.attr('d', function(d:MetroLine) {return that.calcLinkShape(d); });\n\n\n        });\n\n\n        // Restart the layout.\n        force.start();\n\n        return this;\n\n\n    } // end method drawForceDirectedGraph()\n\n\r\n\r\n\r\n    /**\r\n     * When the window is resized, redraw the metrochart graph in its entirety,\r\n     * while observing the new maximum size.\r\n     * @return {[type]} [description]\r\n     */\r\n    protected onResize() {\r\n\r\n        // get the div element that we want to redraw\r\n        let div = this.elemid;\r\n\r\n        // delete the contents of the div\r\n        while (div.firstChild) {\r\n            div.removeChild(div.firstChild);\r\n        }\r\n\r\n        this.draw();\r\n\r\n}\r\n\r\n\r\n\n    /**\n     * Get the color of a line from <code>this.colors</code>, given its index\n     * <code>uindex</code> into <code>this.ulinks</code>. If\n     * <code>this.colors</code> is <code>undefined</code> or zero-length, return\n     * a color string representing 50% gray. If there are not enough colors in\n     * <code>this.colors</code>, use modulo math to determine the appropriate\n     * index into the color table.\n     *\n     * @param {number} uindex Index into <code>this.ulinks</code>\n     *\n     * @return {string} The hexadecimal color string used for drawing\n     * <code>this.ulinks[uindex]</code>.\n     *\n     */\n    public getColor(uindex:number): string {\n\n        let str:string;\n\n        if (typeof this.colors === 'undefined' || this.colors.length === 0) {\n            // in case there are no predefined colors, set all colors to 50% gray\n            str = '#808080';\n        } else {\n            let nColors:number = this.colors.length;\n            // use the modulo-nColors of the uindex value as index into the color table\n            str = this.colors[uindex % nColors];\n        }\n        return str;\n    }\n\n\n\n\n    /**\n     * Method to load the data from <code>this._url</code> using an <code>XMLHttpRequest</code>.\n     */\n    private loaddata() {\n        // load data from local file\n\n        // capture the 'this' object from the current context\n        let that = this;\n\n        let xmlHttp = new XMLHttpRequest();\n\n        // define what to do after the data has been downloaded successfully\n        xmlHttp.onreadystatechange = function() {\n            if (xmlHttp.status === 429) {\n                console.log('Throttle limit exceeded. See \"https://dev.socrata.com/docs/' +\n                            'app-tokens.html#throttling-limits\" for more information.');\n            }\n            if (xmlHttp.readyState === 4 && xmlHttp.status === 200) {\n\n                let data: any = JSON.parse(xmlHttp.responseText);\n\n                // get the nodes and links from the parsed data\n                that.nodes = data.nodes;\n                that.links = data.links;\n\n                // if the data includes an alternative descriptive name for\n                // line, use it, otherwise use 'line'\n                if (typeof data.linelabel === 'undefined') {\n                    that.linelabel = 'line';\n                } else {\n                    that.linelabel = data.linelabel;\n                }\n\n                // if the data includes an alternative descriptive name for\n                // station, use it, otherwise use 'station'\n                if (typeof data.stationlabel === 'undefined') {\n                    that.stationlabel = 'station';\n                } else {\n                    that.stationlabel = data.stationlabel;\n                }\n\n                // if the data includes a data source, use it, otherwise use\n                // 'unknown'\n                if (typeof data.source === 'undefined') {\n                    that.datasource = 'unknown';\n                } else {\n                    that.datasource = data.source;\n                }\n\n                console.log('MetroChart: \\'Done loading data from \"' + that._url + '\"\\'');\r\n\r\n                that.draw();\r\n\n            }\r\n        };\n\n        // make the actual request\n        xmlHttp.open('GET', this._url, true); // true for asynchronous\n\n        // not sure what this is...end the connection?\n        xmlHttp.send(null);\n\n\n    } // end method loaddata()\n\n\n    /**\n     * The graph has nodes of different sizes, depending on how many\n     * metrolines stop at that station. However, you still want the entire\n     * station symbol to remain inside the box defined by the svg drawing area.\n     * This function makes sure that each station remains inside that bounding\n     * box.\n     *\n     * @param {Station} node The station for which the bounding box must be\n     * observed.\n     *\n     * @return {Station} The station with updated .x and .y properties such\n     * that the entire station symbol falls within the bounding box.\n     *\n     */\n    private observeBoundingBox(node:Station):Station {\n\n        // half the width of the entire station symbol\n        let hw: number = this.stationShapeRadius;\n        // half the height of the entire station symbol\n        let hh: number = node.nLines * this.stationShapeRadius;\n\n        // observe the bounding box edge on the right\n        if (node.x > this.w - hw - this.padding.right) {\n            node.x = this.w - hw - this.padding.right;\n        }\n\n        // observe the bounding box edge on the left\n        if (node.x < 0 + hw + this.padding.left) {\n            node.x = 0 + hw + this.padding.left;\n        }\n\n        // observe the bounding box edge on the top\n        if (node.y > this.h - hh - this.labelSpaceVert) {\n            node.y = this.h - hh - this.labelSpaceVert;\n        }\n\n        // observe the bounding box edge on the bottom\n        if (node.y < 0 + hh + this.labelSpaceVert) {\n            node.y = 0 + hh + this.labelSpaceVert;\n        }\n\n        return node;\n\n    }\n\n\n\n\n    /**\n     * Updates the data on the MetroChart object:\n     * <ul>\n     * <li>adds <code>this.nodes.x</code>, <code>this.nodes.y</code>,\n     * <code>this.nodes.nLines</code> for all nodes</li>\n     * <li>calculates minimum time value (<code>this.timeValueLeft</code>) and\n     * maximum time value (<code>this.timeValueRight</code>) if applicable</li>\n     * </ul>\n     *\n     * @return {MetroChart} Returns the MetroChart object with updated data\n     */\n    private verifyData(): MetroChart {\n\n\n        // set the initial position on all nodes:\n        for (let node of this.nodes) {\n            node.x = this.w / 2;\n            node.y = this.h / 2;\n            node.nLines = node.lines.length;\n            if (typeof node.time === 'undefined') {\n                // this node has no associated information that can be used\n                // to position it on a time axis\n                console.log('MetroChart: \\'No time information.\\'');\n            } else if (typeof node.time === 'number') {\n\n                if (node.time < this.timeValueLeft || typeof this.timeValueLeft === 'undefined') {\n                    this.timeValueLeft = node.time;\n                }\n                if (node.time > this.timeValueRight || typeof this.timeValueRight === 'undefined') {\n                    this.timeValueRight = node.time;\n                }\n            } else {\n                throw new MetroChartError(' in .verifyData(): \\'node.time\\'s type should be \\'number\\'.');\n            }\n        }\n        return this;\n    }\n\r\n    public updateWidthHeight() {\r\n        this.w = this.elemid.getBoundingClientRect().width;\r\n        this.h = this.elemid.getBoundingClientRect().height;\r\n    }\r\n\r\n\r\n    // getters and setters from here\n\n    /**\n    * Sets the list of colors to be used for visualizing the lines.\n    */\n    public set colors(colors: string[]) {\n        this._colors = colors;\n    }\n    public get colors():string[] {\n        return this._colors;\n    }\n\n    /**\n    * Defines whether or not to apply the time axis constraint in positioning\n    * the stations horizontally.\n    */\n    public set enableTimeAxis(enableTimeAxis: boolean) {\n        this._enableTimeAxis = enableTimeAxis;\n    }\n    public get enableTimeAxis():boolean {\n        return this._enableTimeAxis;\n    }\n\n    /**\n    * Sets the force-directed graph's charge parameter.\n    */\n    public set charge(charge: number) {\n        this._charge = charge;\n    }\n    public get charge():number {\n        return this._charge;\n    }\n\n\n    /**\n    * Sets the force-directed graph's link distance parameter.\n    */\n    public set linkDistance(linkDistance: number) {\n        this._linkDistance = linkDistance;\n    }\n    public get linkDistance():number {\n        return this._linkDistance;\n    }\n\n\n    /**\n    * Sets the force-directed graph's gravity parameter.\n    */\n    public set gravity(gravity: number) {\n        this._gravity = gravity;\n    }\n    public get gravity():number {\n        return this._gravity;\n    }\n\n    /**\n    * Sets the force-directed graph's link strength parameter.\n    */\n    public set linkStrength(linkStrength: number) {\n        this._linkStrength = linkStrength;\n    }\n    public get linkStrength():number {\n        return this._linkStrength;\n    }\n\n\n    /**\n    * Gets the url of where the data was loaded from.\n    */\n    public get url(): string {\n        return this._url;\n    }\n\n\n}\n","/*\n * Not sure why the {@link MetroChartError} class works like it does\n */\nexport class MetroChartError extends Error {\r\n\n    public message : string;\n    public name    : string;\n\n    constructor(message: string) {\n\n        // call the super class (Error)'s constructor:\n        super(message);\n\n        this.name = 'MetroChartError';\n        this.message = message;\n    }\n}\n"]}